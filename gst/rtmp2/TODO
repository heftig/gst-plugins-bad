- rtmp2sink: Should look into reconnecting and resuming stream without
  deleting and recreating stream, which drops clients.

- Move AMF parser/serializer to GstRtmpMeta?
- Move AMF nodes from g_slice to GstMiniObject?

- Refactor connection, pull out the ad-hoc read and write handling and put it
  with the chunk layer into GBuffered{In,Out}putStream subclasses

- Refactor elements and pull out the common connection+mainloop handling code
  into a context object

- Post-connect onStatus handling (needed for src EOS and async errors?)
  Handle 'user control' stream-eof

- Better mux/demux, at the cost of losing compatibility with flvmux/demux.

  Something like (a/x = application/x-rtmp-messages):

    rtmp2src ! a/x ! rtmp2demux ! a/x,type=video ! rtmp2videodecode ! h264parse
                                ! a/x,type=audio ! rtmp2audiodecode ! aacparse

      x264enc ! rtmp2videoencode ! a/x,type=video ! rtmp2mux ! a/x ! rtmp2sink
    fdkaacenc ! rtmp2audioencode ! a/x,type=audio !

  And also, in case no muxing is required:

      x264enc ! rtmp2videoencode ! a/x,type=video ! rtmp2sink
    fdkaacenc ! rtmp2audioencode ! a/x,type=video ! rtmp2sink

  Proper GstBuffer timestamps need proper timestamp wraparound handling

- Better client element, which generalizes the existing sink/src to allow
  multiple streams over one connection
  - Request src pad to play a stream
  - Request sink pad to publish a stream (base it on GstAggregator?)
  - rtmp2sink/src just specialize the client element with a static pad

- Server implementation

Needed testing:

- AMF parsing

- connection closure by peer

- connection timeouts
